var e,t;e=this,t=function(e){class t{get isConnected(){return null!=this.socket&&this.socket.readyState===this.socket.OPEN}get isConnecting(){return null!=this.socket&&this.socket.readyState===this.socket.CONNECTING}get connState(){return this.socket?this.socket.readyState.toString():""}constructor(e){this.DEFAULT_TIMEOUT=30,this.connstring=e,this.socket=null}async connect(e,t,i=this.DEFAULT_TIMEOUT,o=null,n=null){return new Promise(async(r,c)=>{this.isConnected&&r(this.sessionId),this.serviceName=e,this.solvables=t,null!=o&&(this.machineId=o),null!=n&&(this.sessionId=n),i<=0&&(i=this.DEFAULT_TIMEOUT);try{this.socket=await this.promiseWithTimeout(i,this.tryConnect(this.connstring)),this.sessionId=await this.register()}catch(e){return void c(new Error("Failed to connect: "+e.message))}this.socket.onmessage=e=>{const t=JSON.parse(e.data);if("RequestResponse"===t.method){const e=t.params;let i=s.trackedResponses.findIndex(t=>t.cookie===e.cookie);if(s.trackedResponses.find(t=>t.cookie===e.cookie),i>-1){let t=s.trackedResponses.splice(i,1)[0];e.success?t.responseFuture.resolve(e.result):t.responseFuture.reject(e.result)}}else this.onInform&&this.onInform(e.data)},this.socket.onerror=e=>{this.onError&&this.onError("Error connecting to STP. Check that the service is running and refresh page to retry")},this.socket.onclose=async e=>{if(!this.isConnecting)try{await this.connect(this.serviceName,this.solvables,this.timeout,this.machineId)}catch(e){this.onError&&this.onError("Lost connection to STP. Check that the service is running and refresh page to retry")}},r(this.sessionId)})}register(e=this.DEFAULT_TIMEOUT){if(!this.isConnected)throw new Error("Failed to register: connection is not open ("+this.connState+")");this.name=this.serviceName;let t=JSON.stringify({method:"Register",params:{serviceName:this.serviceName,language:"javascript",solvables:this.solvables,machineId:this.machineId||this.getUniqueId(9),sessionId:this.sessionId}});return this.request(t,e)}disconnect(e=this.DEFAULT_TIMEOUT){return this.promiseWithTimeout(e,new Promise(async(e,t)=>{!this.isConnected&&this.socket&&this.socket.close(),e()}))}inform(e,t=this.DEFAULT_TIMEOUT){if(!this.isConnected)throw new Error("Failed to send inform: connection is not open ("+this.connState+")");return this.promiseWithTimeout(t,new Promise(async(t,s)=>{this.socket&&(this.socket.send(e),t())}))}async request(e,t=this.DEFAULT_TIMEOUT){if(!this.isConnected||!this.socket)throw new Error("Failed to send request: connection is not open ("+this.connState+")");let i=new s;return this.promiseWithTimeout(t,new Promise(async(s,o)=>{if(!this.socket)return;const n={method:"Request",params:{jsonRequest:e,cookie:i.cookie,timeout:t}};this.socket.send(JSON.stringify(n)),i.responseFuture.then(e=>s(e)).catch(e=>o(e))}))}tryConnect(e){return new Promise((t,s)=>{var i=new WebSocket(e);i.onopen=()=>t(i),i.onerror=e=>s(new Error("Unspecified error communicating with STP"))})}promiseWithTimeout(e,t){return Promise.race([t,new Promise((t,s)=>{let i=setTimeout(()=>{clearTimeout(i),s(new Error("Operation timed out"))},1e3*e)})])}getUniqueId(e){return e||(e=9),Math.random().toString(36).substr(2,e)}}class s{constructor(){this.cookie=s.lastCookie++,this.responseFuture=new i,s.trackedResponses.push(this)}}s.lastCookie=0,s.trackedResponses=[];class i{constructor(e){if(!(this instanceof i))return new i(e);this.promise=e||new Promise(this.promiseExecutor.bind(this))}asPromise(){return this.promise}then(e,t){return new i(this.promise.then(e,t))}catch(e){return new i(this.promise.catch(e))}resolve(e){this.resolveFunction(e)}reject(e){this.rejectFunction(e)}promiseExecutor(e,t){this.resolveFunction=e,this.rejectFunction=t}}e.StpWebSocketsConnector=t,e.default=t,Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).StpWS={});